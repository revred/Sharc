/*-------------------------------------------------------------------------------------------------!
  "Where the mind is free to imagine and the craft is guided by clarity, code awakens."            |

  A collaborative work shaped by Artificial Intelligence and curated with intent by Ram Revanur.
  Licensed under the MIT License — free for personal and commercial use.                           |
--------------------------------------------------------------------------------------------------*/

using System.Runtime.CompilerServices;
using BenchmarkDotNet.Attributes;
using Microsoft.Data.Sqlite;
using Sharc.Core.Query;

namespace Sharc.Comparisons;

/// <summary>
/// Core browser database benchmarks comparing Sharc vs SQLite.
/// These map directly to the 16 Arena benchmark slides, producing
/// real measured numbers for use in the live WASM benchmark arena.
///
/// All benchmarks use identical data generated by the shared GraphGenerator.
/// Dataset: 5K users (9 columns), 5K graph nodes, 15K graph edges.
///
/// Key browser advantages of Sharc:
///   - Zero WASM binary download (pure managed C#)
///   - Zero-alloc Span pipeline (no GC pressure)
///   - In-process B-tree (no P/Invoke or IPC)
///   - Sub-µs seeks via binary search descent
/// </summary>
[MemoryDiagnoser]
public class CoreBenchmarks
{
    private string _dbPath = null!;
    private byte[] _dbBytes = null!;
    private SqliteConnection _conn = null!;
    private SharcDatabase _sharcDb = null!;
    private IFilterNode _cachedFilterNode = null!;

    // ── Prepared handles (zero-alloc hot paths) ──────────────────────
    private PreparedReader _preparedReader = null!;       // PointLookup + BatchLookup
    private SqliteCommand _sqlitePreparedPoint = null!;   // SQLite prepared PointLookup
    private PreparedReader _preparedSeqScan = null!;      // SequentialScan (9 cols)
    private PreparedReader _preparedTypeDecode = null!;   // TypeDecode + GcPressure ("id")
    private PreparedReader _preparedNullScan = null!;     // NullScan ("bio")
    private PreparedQuery _preparedWhereFilter = null!;   // WhereFilter (age > 30 AND score < 50)
    private PreparedQuery _preparedFilterStar = null!;    // FilterStar (same filter, via Prepare)

    // ── Random rowid buffer for fair point lookup benchmarks ────────
    // 512-entry circular buffer: small enough to stay cache-friendly,
    // large enough to defeat same-rowid/same-leaf fast paths.
    private const int RandomBufSize = 512;
    private long[] _randomBuf = null!;
    private int _randomIdx;
    private Random _rng = null!;

    [GlobalSetup]
    public void Setup()
    {
        var dir = Path.Combine(Path.GetTempPath(), "sharc_core_bench");
        Directory.CreateDirectory(dir);
        _dbPath = Path.Combine(dir, "core_bench.db");

        if (!File.Exists(_dbPath))
            CoreDataGenerator.GenerateSQLite(_dbPath, userCount: 5000);
        _dbBytes = File.ReadAllBytes(_dbPath);

        _conn = new SqliteConnection($"Data Source={_dbPath};Mode=ReadOnly");
        _conn.Open();

        // Pre-compile the Baked filter for fair comparison (bypass delegate construction overhead per call)
        _sharcDb = SharcDatabase.OpenMemory(_dbBytes, new SharcOpenOptions { PageCacheSize = 100 });
        var tables = _sharcDb.Schema.Tables;
        var filter = FilterStar.And(
            FilterStar.Column("age").Gt(30),
            FilterStar.Column("score").Lt(50.0)
        );
        for (int i = 0; i < tables.Count; i++)
        {
            if (tables[i].Name == "users")
            {
                _cachedFilterNode = FilterTreeCompiler.CompileBaked(filter, tables[i].Columns);
                break;
            }
        }

        // ── SQLite prepared command (skip parse + plan on hot path) ──
        _sqlitePreparedPoint = _conn.CreateCommand();
        _sqlitePreparedPoint.CommandText = "SELECT id FROM users WHERE rowid = 2500";
        _sqlitePreparedPoint.Prepare();

        // ── 512-entry random rowid buffer (fixed seed, no per-call alloc) ─
        _rng = new Random(42);
        _randomBuf = new long[RandomBufSize];
        RefillRandomBuf();

        // ── Prepared readers (resolve schema + cursor once) ──────────
        _preparedReader = _sharcDb.PrepareReader("users");
        _preparedSeqScan = _sharcDb.PrepareReader("users",
            "id", "name", "email", "age", "score", "bio", "active", "dept", "created");
        _preparedTypeDecode = _sharcDb.PrepareReader("users", "id");
        _preparedNullScan = _sharcDb.PrepareReader("users", "bio");

        // ── Prepared queries (resolve schema + filter + cursor once) ──
        _preparedWhereFilter = _sharcDb.Prepare(
            "SELECT id FROM users WHERE age > 30 AND score < 50");
        _preparedFilterStar = _sharcDb.Prepare(
            "SELECT id FROM users WHERE age > 30 AND score < 50");
    }

    [GlobalCleanup]
    public void Cleanup()
    {
        _preparedReader?.Dispose();
        _preparedSeqScan?.Dispose();
        _preparedTypeDecode?.Dispose();
        _preparedNullScan?.Dispose();
        _preparedWhereFilter?.Dispose();
        _preparedFilterStar?.Dispose();
        _sqlitePreparedPoint?.Dispose();
        _conn?.Dispose();
        _sharcDb?.Dispose();
    }

    // ═══════════════════════════════════════════════════════════════
    //  1. ENGINE LOAD — open database from bytes
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("EngineLoad")]
    public SharcDatabase Sharc_EngineLoad()
    {
        var db = SharcDatabase.OpenMemory(_dbBytes);
        db.Dispose();
        return db;
    }

    [Benchmark]
    [BenchmarkCategory("EngineLoad")]
    public SqliteConnection SQLite_EngineLoad()
    {
        var conn = new SqliteConnection($"Data Source={_dbPath};Mode=ReadOnly");
        conn.Open();
        // Force schema load
        using var cmd = conn.CreateCommand();
        cmd.CommandText = "SELECT COUNT(*) FROM sqlite_master";
        _ = cmd.ExecuteScalar();
        conn.Dispose();
        return conn;
    }

    // ═══════════════════════════════════════════════════════════════
    //  2. SCHEMA READ — introspect tables and columns
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("SchemaRead")]
    public int Sharc_SchemaRead()
    {
        using var db = SharcDatabase.OpenMemory(_dbBytes, new SharcOpenOptions { PageCacheSize = 0 });
        var tables = db.Schema.Tables;
        var totalColumns = 0;
        foreach (var t in tables)
            totalColumns += t.Columns.Count;
        return totalColumns;
    }

    [Benchmark]
    [BenchmarkCategory("SchemaRead")]
    public int SQLite_SchemaRead()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT name, sql FROM sqlite_master WHERE type='table'";
        using var reader = cmd.ExecuteReader();
        int columnCount = 0;
        while (reader.Read())
        {
            var sql = reader.GetString(1);
            columnCount += sql.Split(',').Length;
        }
        return columnCount;
    }

    // ═══════════════════════════════════════════════════════════════
    //  3. SEQUENTIAL SCAN — full table read, all columns decoded
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("SequentialScan")]
    public long Sharc_SequentialScan()
    {
        using var reader = _preparedSeqScan.CreateReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);     // id
            _ = reader.GetString(1);    // name
            _ = reader.GetString(2);    // email
            _ = reader.GetInt64(3);     // age
            _ = reader.GetDouble(4);    // score
            if (!reader.IsNull(5))
                _ = reader.GetString(5); // bio (nullable)
            _ = reader.GetInt64(6);     // active
            _ = reader.GetString(7);    // dept
            _ = reader.GetString(8);    // created
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("SequentialScan")]
    public long Sharc_SequentialScan_Cold()
    {
        var columns = new[] { "id", "name", "email", "age", "score", "bio", "active", "dept", "created" };
        using var reader = _sharcDb.CreateReader("users", columns);
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);     // id
            _ = reader.GetString(1);    // name
            _ = reader.GetString(2);    // email
            _ = reader.GetInt64(3);     // age
            _ = reader.GetDouble(4);    // score
            if (!reader.IsNull(5))
                _ = reader.GetString(5); // bio (nullable)
            _ = reader.GetInt64(6);     // active
            _ = reader.GetString(7);    // dept
            _ = reader.GetString(8);    // created
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("SequentialScan")]
    public long SQLite_SequentialScan()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT id, name, email, age, score, bio, active, dept, created FROM users";
        using var reader = cmd.ExecuteReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            _ = reader.GetString(1);
            _ = reader.GetString(2);
            _ = reader.GetInt64(3);
            _ = reader.GetDouble(4);
            if (!reader.IsDBNull(5))
                _ = reader.GetString(5);
            _ = reader.GetInt64(6);
            _ = reader.GetString(7);
            _ = reader.GetString(8);
            count++;
        }
        return count;
    }

    // ═══════════════════════════════════════════════════════════════
    //  4. POINT LOOKUP — single row by primary key (B-tree seek)
    //
    //  Single seek per invocation — BDN DefaultJob auto-selects a
    //  high InvocationCount for sub-us methods (typically 32K-131K),
    //  giving accurate per-op timing without manual batching.
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("PointLookup")]
    public long Sharc_PointLookup()
    {
        using var reader = _preparedReader.CreateReader();
        if (reader.Seek(2500))
            return reader.GetInt64(0);
        return -1;
    }

    [Benchmark]
    [BenchmarkCategory("PointLookup")]
    public long Sharc_PointLookup_Cold()
    {
        using var reader = _sharcDb.CreateReader("users");
        if (reader.Seek(2500))
            return reader.GetInt64(0);
        return -1;
    }

    [Benchmark]
    [BenchmarkCategory("PointLookup")]
    public long SQLite_PointLookup()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT id FROM users WHERE rowid = 2500";
        return Convert.ToInt64(cmd.ExecuteScalar());
    }

    [Benchmark]
    [BenchmarkCategory("PointLookup")]
    public long SQLite_PointLookup_Prepared()
    {
        return Convert.ToInt64(_sqlitePreparedPoint.ExecuteScalar());
    }

    // ═══════════════════════════════════════════════════════════════
    //  4b. RANDOM POINT LOOKUP — different rowid each invocation
    //
    //  Cycles through a 512-entry random rowid buffer.
    //  Refills the same buffer (zero alloc) when exhausted.
    //  Defeats same-rowid/same-leaf caching for honest measurement.
    // ═══════════════════════════════════════════════════════════════

    private void RefillRandomBuf()
    {
        for (int i = 0; i < RandomBufSize; i++)
            _randomBuf[i] = _rng.NextInt64(1, 5001); // [1..5000]
        _randomIdx = 0;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private long NextRandomRowId()
    {
        if (_randomIdx >= RandomBufSize)
            RefillRandomBuf();
        return _randomBuf[_randomIdx++];
    }

    [Benchmark]
    [BenchmarkCategory("RandomLookup")]
    public long Sharc_RandomLookup()
    {
        using var reader = _preparedReader.CreateReader();
        if (reader.Seek(NextRandomRowId()))
            return reader.GetInt64(0);
        return -1;
    }

    [Benchmark]
    [BenchmarkCategory("RandomLookup")]
    public long SQLite_RandomLookup()
    {
        long rid = NextRandomRowId();
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = $"SELECT id FROM users WHERE rowid = {rid}";
        return Convert.ToInt64(cmd.ExecuteScalar());
    }

    // ═══════════════════════════════════════════════════════════════
    //  5. BATCH LOOKUP — 6 consecutive seeks (page cache locality)
    // ═══════════════════════════════════════════════════════════════

    private static readonly long[] BatchTargets = [1, 50, 500, 1000, 2500, 4999];

    [Benchmark]
    [BenchmarkCategory("BatchLookup")]
    public long Sharc_BatchLookup()
    {
        using var reader = _preparedReader.CreateReader();
        long sum = 0;
        foreach (var target in BatchTargets)
        {
            if (reader.Seek(target))
                sum += reader.GetInt64(0);
        }
        return sum;
    }

    [Benchmark]
    [BenchmarkCategory("BatchLookup")]
    public long SQLite_BatchLookup()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT id FROM users WHERE rowid = $id";
        var p = cmd.Parameters.Add("$id", SqliteType.Integer);
        cmd.Prepare();

        long sum = 0;
        foreach (var target in BatchTargets)
        {
            p.Value = target;
            sum += Convert.ToInt64(cmd.ExecuteScalar());
        }
        return sum;
    }

    // ═══════════════════════════════════════════════════════════════
    //  6. TYPE DECODE — raw integer decode speed
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("TypeDecode")]
    public long Sharc_TypeDecode()
    {
        using var reader = _preparedTypeDecode.CreateReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("TypeDecode")]
    public long Sharc_TypeDecode_Cold()
    {
        using var reader = _sharcDb.CreateReader("users", "id");
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("TypeDecode")]
    public long SQLite_TypeDecode()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT id FROM users";
        using var reader = cmd.ExecuteReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    // ═══════════════════════════════════════════════════════════════
    //  7. NULL SCAN — check NULL without full decode
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("NullScan")]
    public long Sharc_NullScan()
    {
        using var reader = _preparedNullScan.CreateReader();
        long nullCount = 0;
        while (reader.Read())
        {
            if (reader.IsNull(0)) nullCount++;
        }
        return nullCount;
    }

    [Benchmark]
    [BenchmarkCategory("NullScan")]
    public long Sharc_NullScan_Cold()
    {
        using var reader = _sharcDb.CreateReader("users", "bio");
        long nullCount = 0;
        while (reader.Read())
        {
            if (reader.IsNull(0)) nullCount++;
        }
        return nullCount;
    }

    [Benchmark]
    [BenchmarkCategory("NullScan")]
    public long SQLite_NullScan()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT bio FROM users";
        using var reader = cmd.ExecuteReader();
        long nullCount = 0;
        while (reader.Read())
        {
            if (reader.IsDBNull(0)) nullCount++;
        }
        return nullCount;
    }

    // ═══════════════════════════════════════════════════════════════
    //  8. WHERE FILTER — scan + comparison filter
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("WhereFilter")]
    public long Sharc_WhereFilter()
    {
        using var reader = _preparedWhereFilter.Execute();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("WhereFilter")]
    public long Sharc_WhereFilter_Cold()
    {
        var filters = new[]
        {
            new SharcFilter("age", SharcOperator.GreaterThan, (long)30),
            new SharcFilter("score", SharcOperator.LessThan, 50.0),
        };
        using var reader = _sharcDb.CreateReader("users", ["id"], filters);
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("WhereFilter")]
    public long SQLite_WhereFilter()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT id FROM users WHERE age > 30 AND score < 50";
        using var reader = cmd.ExecuteReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("FilterStar")]
    public long Sharc_FilterStar()
    {
        using var reader = _preparedFilterStar.Execute();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("FilterStar")]
    public long Sharc_FilterStar_Cold()
    {
        // Pre-compiled filter node — bypasses Compile overhead, only measures Evaluate speed
        using var reader = _sharcDb.CreateReader("users", ["id"], _cachedFilterNode);
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    // ═══════════════════════════════════════════════════════════════
    //  9. GC PRESSURE — sustained integer scan (allocation tracking)
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("GcPressure")]
    public long Sharc_GcPressure()
    {
        using var reader = _preparedTypeDecode.CreateReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("GcPressure")]
    public long Sharc_GcPressure_Cold()
    {
        using var reader = _sharcDb.CreateReader("users", "id");
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("GcPressure")]
    public long SQLite_GcPressure()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT id FROM users";
        using var reader = cmd.ExecuteReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }
}
