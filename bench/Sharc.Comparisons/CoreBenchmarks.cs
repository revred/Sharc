/*-------------------------------------------------------------------------------------------------!
  "Where the mind is free to imagine and the craft is guided by clarity, code awakens."            |

  A collaborative work shaped by Artificial Intelligence and curated with intent by Ram Revanur.
  Licensed under the MIT License — free for personal and commercial use.                           |
--------------------------------------------------------------------------------------------------*/

using BenchmarkDotNet.Attributes;
using Microsoft.Data.Sqlite;
using Sharc.Core.Query;

namespace Sharc.Comparisons;

/// <summary>
/// Core browser database benchmarks comparing Sharc vs SQLite.
/// These map directly to the 16 Arena benchmark slides, producing
/// real measured numbers for use in the live WASM benchmark arena.
///
/// All benchmarks use identical data generated by the shared GraphGenerator.
/// Dataset: 5K users (9 columns), 5K graph nodes, 15K graph edges.
///
/// Key browser advantages of Sharc:
///   - Zero WASM binary download (pure managed C#)
///   - Zero-alloc Span pipeline (no GC pressure)
///   - In-process B-tree (no P/Invoke or IPC)
///   - Sub-µs seeks via binary search descent
/// </summary>
[MemoryDiagnoser]
public class CoreBenchmarks
{
    private string _dbPath = null!;
    private byte[] _dbBytes = null!;
    private SqliteConnection _conn = null!;
    private SharcDatabase _sharcDb = null!;
    private IFilterNode _cachedFilterNode = null!;
    private PreparedReader _preparedReader = null!;

    [GlobalSetup]
    public void Setup()
    {
        var dir = Path.Combine(Path.GetTempPath(), "sharc_core_bench");
        Directory.CreateDirectory(dir);
        _dbPath = Path.Combine(dir, "core_bench.db");

        if (!File.Exists(_dbPath))
            CoreDataGenerator.GenerateSQLite(_dbPath, userCount: 5000);
        _dbBytes = File.ReadAllBytes(_dbPath);

        _conn = new SqliteConnection($"Data Source={_dbPath};Mode=ReadOnly");
        _conn.Open();

        // Pre-compile the Baked filter for fair comparison (bypass delegate construction overhead per call)
        _sharcDb = SharcDatabase.OpenMemory(_dbBytes, new SharcOpenOptions { PageCacheSize = 100 });
        var tables = _sharcDb.Schema.Tables;
        var filter = FilterStar.And(
            FilterStar.Column("age").Gt(30),
            FilterStar.Column("score").Lt(50.0)
        );
        for (int i = 0; i < tables.Count; i++)
        {
            if (tables[i].Name == "users")
            {
                _cachedFilterNode = FilterTreeCompiler.CompileBaked(filter, tables[i].Columns);
                break;
            }
        }

        _preparedReader = _sharcDb.PrepareReader("users");
    }

    [GlobalCleanup]
    public void Cleanup()
    {
        _preparedReader?.Dispose();
        _conn?.Dispose();
        _sharcDb?.Dispose();
    }

    // ═══════════════════════════════════════════════════════════════
    //  1. ENGINE LOAD — open database from bytes
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("EngineLoad")]
    public SharcDatabase Sharc_EngineLoad()
    {
        var db = SharcDatabase.OpenMemory(_dbBytes);
        db.Dispose();
        return db;
    }

    [Benchmark]
    [BenchmarkCategory("EngineLoad")]
    public SqliteConnection SQLite_EngineLoad()
    {
        var conn = new SqliteConnection($"Data Source={_dbPath};Mode=ReadOnly");
        conn.Open();
        // Force schema load
        using var cmd = conn.CreateCommand();
        cmd.CommandText = "SELECT COUNT(*) FROM sqlite_master";
        _ = cmd.ExecuteScalar();
        conn.Dispose();
        return conn;
    }

    // ═══════════════════════════════════════════════════════════════
    //  2. SCHEMA READ — introspect tables and columns
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("SchemaRead")]
    public int Sharc_SchemaRead()
    {
        using var db = SharcDatabase.OpenMemory(_dbBytes, new SharcOpenOptions { PageCacheSize = 0 });
        var tables = db.Schema.Tables;
        var totalColumns = 0;
        foreach (var t in tables)
            totalColumns += t.Columns.Count;
        return totalColumns;
    }

    [Benchmark]
    [BenchmarkCategory("SchemaRead")]
    public int SQLite_SchemaRead()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT name, sql FROM sqlite_master WHERE type='table'";
        using var reader = cmd.ExecuteReader();
        int columnCount = 0;
        while (reader.Read())
        {
            var sql = reader.GetString(1);
            columnCount += sql.Split(',').Length;
        }
        return columnCount;
    }

    // ═══════════════════════════════════════════════════════════════
    //  3. SEQUENTIAL SCAN — full table read, all columns decoded
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("SequentialScan")]
    public long Sharc_SequentialScan()
    {
        var columns = new[] { "id", "name", "email", "age", "score", "bio", "active", "dept", "created" };
        using var reader = _sharcDb.CreateReader("users", columns);
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);     // id
            _ = reader.GetString(1);    // name
            _ = reader.GetString(2);    // email
            _ = reader.GetInt64(3);     // age
            _ = reader.GetDouble(4);    // score
            if (!reader.IsNull(5))
                _ = reader.GetString(5); // bio (nullable)
            _ = reader.GetInt64(6);     // active
            _ = reader.GetString(7);    // dept
            _ = reader.GetString(8);    // created
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("SequentialScan")]
    public long SQLite_SequentialScan()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT id, name, email, age, score, bio, active, dept, created FROM users";
        using var reader = cmd.ExecuteReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            _ = reader.GetString(1);
            _ = reader.GetString(2);
            _ = reader.GetInt64(3);
            _ = reader.GetDouble(4);
            if (!reader.IsDBNull(5))
                _ = reader.GetString(5);
            _ = reader.GetInt64(6);
            _ = reader.GetString(7);
            _ = reader.GetString(8);
            count++;
        }
        return count;
    }

    // ═══════════════════════════════════════════════════════════════
    //  4. POINT LOOKUP — single row by primary key (B-tree seek)
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("PointLookup")]
    public long Sharc_PointLookup()
    {
        using var reader = _preparedReader.CreateReader();
        if (reader.Seek(2500))
            return reader.GetInt64(0);
        return -1;
    }

    [Benchmark]
    [BenchmarkCategory("PointLookup")]
    public long Sharc_PointLookup_Cold()
    {
        using var reader = _sharcDb.CreateReader("users");
        if (reader.Seek(2500))
            return reader.GetInt64(0);
        return -1;
    }

    [Benchmark]
    [BenchmarkCategory("PointLookup")]
    public long SQLite_PointLookup()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT id FROM users WHERE rowid = 2500";
        return Convert.ToInt64(cmd.ExecuteScalar());
    }

    // ═══════════════════════════════════════════════════════════════
    //  5. BATCH LOOKUP — 6 consecutive seeks (page cache locality)
    // ═══════════════════════════════════════════════════════════════

    private static readonly long[] BatchTargets = [1, 50, 500, 1000, 2500, 4999];

    [Benchmark]
    [BenchmarkCategory("BatchLookup")]
    public long Sharc_BatchLookup()
    {
        using var reader = _preparedReader.CreateReader();
        long sum = 0;
        foreach (var target in BatchTargets)
        {
            if (reader.Seek(target))
                sum += reader.GetInt64(0);
        }
        return sum;
    }

    [Benchmark]
    [BenchmarkCategory("BatchLookup")]
    public long SQLite_BatchLookup()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT id FROM users WHERE rowid = $id";
        var p = cmd.Parameters.Add("$id", SqliteType.Integer);
        cmd.Prepare();

        long sum = 0;
        foreach (var target in BatchTargets)
        {
            p.Value = target;
            sum += Convert.ToInt64(cmd.ExecuteScalar());
        }
        return sum;
    }

    // ═══════════════════════════════════════════════════════════════
    //  6. TYPE DECODE — raw integer decode speed
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("TypeDecode")]
    public long Sharc_TypeDecode()
    {
        using var reader = _sharcDb.CreateReader("users", "id");
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("TypeDecode")]
    public long SQLite_TypeDecode()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT id FROM users";
        using var reader = cmd.ExecuteReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    // ═══════════════════════════════════════════════════════════════
    //  7. NULL SCAN — check NULL without full decode
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("NullScan")]
    public long Sharc_NullScan()
    {
        using var reader = _sharcDb.CreateReader("users", "bio");
        long nullCount = 0;
        while (reader.Read())
        {
            if (reader.IsNull(0)) nullCount++;
        }
        return nullCount;
    }

    [Benchmark]
    [BenchmarkCategory("NullScan")]
    public long SQLite_NullScan()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT bio FROM users";
        using var reader = cmd.ExecuteReader();
        long nullCount = 0;
        while (reader.Read())
        {
            if (reader.IsDBNull(0)) nullCount++;
        }
        return nullCount;
    }

    // ═══════════════════════════════════════════════════════════════
    //  8. WHERE FILTER — scan + comparison filter
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("WhereFilter")]
    public long Sharc_WhereFilter()
    {
        var filters = new[]
        {
            new SharcFilter("age", SharcOperator.GreaterThan, (long)30),
            new SharcFilter("score", SharcOperator.LessThan, 50.0),
        };
        using var reader = _sharcDb.CreateReader("users", ["id"], filters);
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("WhereFilter")]
    public long SQLite_WhereFilter()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT id FROM users WHERE age > 30 AND score < 50";
        using var reader = cmd.ExecuteReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("FilterStar")]
    public long Sharc_FilterStar()
    {
        // Use the pre-compiled node via an internal hack or by setting it on the reader.
        // For benchmarking the 'Evaluate' speed, we want to bypass 'Compile' inside CreateReader.
        using var reader = _sharcDb.CreateReader("users", ["id"], _cachedFilterNode);
        
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    // ═══════════════════════════════════════════════════════════════
    //  9. GC PRESSURE — sustained integer scan (allocation tracking)
    // ═══════════════════════════════════════════════════════════════

    [Benchmark]
    [BenchmarkCategory("GcPressure")]
    public long Sharc_GcPressure()
    {
        using var reader = _sharcDb.CreateReader("users", "id");
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("GcPressure")]
    public long SQLite_GcPressure()
    {
        using var cmd = _conn.CreateCommand();
        cmd.CommandText = "SELECT id FROM users";
        using var reader = cmd.ExecuteReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }
}
