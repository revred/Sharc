# Cryptographic Support: ECDSA P-256

This document outlines the architectural changes necessary to support asymmetric cryptography—specifically ECDSA P-256—within the Sharc Core trust ledger.

## Current State & Limitations

Currently, the Sharc Core trust layer natively assumes and hardcodes **HMAC-SHA256** (symmetric) cryptography for agent identity and signature verification.

### Identity Registration (`AgentRegistry.cs`)

When a new agent registers via `AgentRegistry.RegisterAgent(AgentInfo agent)`, the system verifies the registration signature using a static invocation of `SharcSigner`:

```csharp
if (!SharcSigner.Verify(GetVerificationBuffer(agent), agent.Signature, agent.PublicKey))
    throw new InvalidOperationException("Invalid signature.");
```

Because `SharcSigner` is strictly an HMAC-SHA256 implementation:
1. It expects the `"Public Key"` to actually be the symmetric shared secret.
2. It generates a strict 32-byte hash buffer.
3. It completely rejects 64-byte ECDSA P-256 signatures generated by hardware-accelerated asymmetric signers (like `WasmWebCryptoSigner`).

This creates a rigid coupling where only symmetric HMAC agents can be registered to the ledger.

## Implementation Plan for ECDSA P-256

To modernize Sharc's trust ledger and support `WasmWebCryptoSigner` natively, the following subsystems must be updated:

### 1. Cryptographic Algorithm Signalling

The `AgentInfo` and `TrustPayload` records currently do not encode which cryptographic algorithm produced their signatures.

**Action Required:**
- Introduce a `SignatureAlgorithm` enum (e.g., `HMAC_SHA256`, `ECDSA_P256`).
- Include this algorithm identifier in `AgentInfo` during registration.
- Store the algorithm identifier in the `_sharc_agents` table schema so the `AgentRegistry` knows how to verify incoming data.

### 2. Pluggable Verification Strategies

The `AgentRegistry` and `LedgerManager` should not depend directly on a concrete implementation (`SharcSigner.Verify`). Verification logic should be polymorphic based on the registered `SignatureAlgorithm`.

**Action Required:**
- Create an `ISignatureVerifier` interface or a factory that resolves the correct verification strategy.
- When `LedgerManager.AppendAsync` attempts to validate an entry, it should look up the agent's registered `SignatureAlgorithm` and dispatch the payload and signature to the respective verifier (HMAC or ECDSA).

### 3. ECDSA Verification in Sharc Core (.NET Native)

While the WASM layer can use `webCryptoBridge` to asynchronously verify ECDSA signatures, the core Sharc library needs a native .NET implementation to verify ECDSA signatures when running outside the browser (e.g., server-side consensus nodes).

**Action Required:**
- Implement a managed `EcdsaVerifier` using `System.Security.Cryptography.ECDsa`.
- The verifier must correctly parser the raw 64-byte (r + s) representation of ECDSA signatures that Web Crypto produces, or wrap them in standard DER encoding if required by the .NET `ECDsa` class.

### 4. Asynchronous Pipeline (Completed)

Asymmetric operations (especially Web Crypto in the browser) are often hardware-accelerated and strictly asynchronous.

**Action Taken:**
- The Sharc signature interfaces (`ISharcSigner.SignAsync`, `LedgerManager.AppendAsync`) have already been refactored to support `Task`-based asynchronous execution.
- This prevents thread-blocking in single-threaded WebAssembly environments like Blazor.

## Conclusion

By decoupling the signature verification logic from `HMAC-SHA256` and introducing polymorphic algorithm support, Sharc's Trust Layer will cleanly support `WasmWebCryptoSigner` and true public-key infrastructure (PKI), preventing the current `Invalid signature` rejection errors when bridging different cryptographic paradigms.
