// Copyright (c) Ram Revanur. All rights reserved.
// Licensed under the MIT License.


using System.Diagnostics;
using Microsoft.Data.Sqlite;
using Sharc.Arena.Wasm.Models;

namespace Sharc.Arena.Wasm.Services;

/// <summary>
/// Tier 1 live engine: runs Microsoft.Data.Sqlite directly in .NET WASM.
/// Same runtime as Sharc — identical timing (Stopwatch + GC alloc tracking).
/// SQLitePCLRaw bundles e_sqlite3 compiled to WASM via Emscripten, accessed via P/Invoke.
/// </summary>
public sealed class SqliteEngine : IDisposable
{
    private SqliteConnection? _connection;
    private byte[]? _dbBytes;
    private string? _tempPath;

    /// <summary>Exposes the live connection for query pipeline execution.</summary>
    internal SqliteConnection? Connection => _connection;

    /// <summary>
    /// Ensures the database is opened from pre-generated bytes.
    /// Accepts pre-generated byte[] to avoid redundant DataGenerator runs.
    /// </summary>
    public (double Ms, long AllocBytes) EnsureInitialized(byte[] dbBytes)
    {
        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        Cleanup();

        _dbBytes = dbBytes;
        _tempPath = Path.GetTempFileName();
        File.WriteAllBytes(_tempPath, _dbBytes);

        _connection = new SqliteConnection($"Data Source={_tempPath};Mode=ReadOnly");
        _connection.Open();

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();
        return (sw.Elapsed.TotalMilliseconds, allocAfter - allocBefore);
    }

    public EngineBaseResult RunEngineLoad()
    {
        if (_dbBytes is null) return new EngineBaseResult { Value = null, Note = "No data" };

        // Re-open: measure just the connection open from file bytes
        Cleanup();

        _tempPath = Path.GetTempFileName();
        File.WriteAllBytes(_tempPath, _dbBytes);

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        _connection = new SqliteConnection($"Data Source={_tempPath};Mode=ReadOnly");
        _connection.Open();

        // Force schema load (sqlite reads header + schema on first query)
        using var cmd = _connection.CreateCommand();
        cmd.CommandText = "SELECT COUNT(*) FROM sqlite_master";
        _ = cmd.ExecuteScalar();

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();
        var allocKb = (allocAfter - allocBefore) / 1024.0;

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMilliseconds, 3),
            Allocation = $"{allocKb:F1} KB",
            Note = "Microsoft.Data.Sqlite — in-process P/Invoke",
        };
    }

    public EngineBaseResult RunSchemaRead()
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warm-up
        RunSchemaQuery();

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        var (tableCount, columnCount) = RunSchemaQuery();

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMicroseconds(), 1),
            Allocation = FormatAlloc(allocAfter - allocBefore),
            Note = $"{tableCount} tables, {columnCount} columns",
        };
    }

    public EngineBaseResult RunSequentialScan(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warm-up
        RunFullScan("users");

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        var rowCount = RunFullScan("users");

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMilliseconds, 2),
            Allocation = FormatAlloc(allocAfter - allocBefore),
            Note = $"{rowCount} rows decoded (SELECT *)",
        };
    }

    public EngineBaseResult RunPointLookup()
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        var rowCount = GetRowCount("users");
        var targetId = Math.Max(1, rowCount / 2);

        // Warm-up
        RunSeek("users", targetId);

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        var found = RunSeek("users", targetId);

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalNanoseconds(), 0),
            Allocation = FormatAlloc(allocAfter - allocBefore),
            Note = $"rowid={targetId}, found={found}",
        };
    }

    public EngineBaseResult RunBatchLookup(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        var rowCount = GetRowCount("users");
        var lookupCount = Math.Max(1, (int)(6 * scale));
        var rng = new Random(42);

        // Warm-up
        RunSeek("users", 1);

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = "SELECT * FROM users WHERE rowid = $id";
        var pId = cmd.Parameters.Add("$id", SqliteType.Integer);
        cmd.Prepare();

        for (int i = 0; i < lookupCount; i++)
        {
            pId.Value = rng.NextInt64(1, rowCount + 1);
            using var reader = cmd.ExecuteReader();
            if (reader.Read())
            {
                _ = reader.GetInt64(0);
                _ = reader.GetString(1);
            }
        }

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalNanoseconds(), 0),
            Allocation = FormatAlloc(allocAfter - allocBefore),
            Note = $"{lookupCount} seeks (prepared statement)",
        };
    }

    public EngineBaseResult RunTypeDecode(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warm-up
        RunColumnScan("users", "id");

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        var count = RunColumnScan("users", "id");

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMilliseconds, 2),
            Allocation = FormatAlloc(allocAfter - allocBefore),
            Note = $"{count} integers decoded (SELECT id)",
        };
    }

    public EngineBaseResult RunNullScan(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warm-up
        RunNullCount("users", "bio");

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        var (nullCount, totalCount) = RunNullCount("users", "bio");

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMicroseconds(), 0),
            Allocation = FormatAlloc(allocAfter - allocBefore),
            Note = $"{nullCount}/{totalCount} nulls (bio column)",
        };
    }

    public EngineBaseResult RunWhereFilter(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warm-up
        RunFilteredQuery("SELECT * FROM users WHERE age > 30 AND score < 50");

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        var matchCount = RunFilteredQuery("SELECT * FROM users WHERE age > 30 AND score < 50");

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMilliseconds, 2),
            Allocation = FormatAlloc(allocAfter - allocBefore),
            Note = $"{matchCount} matches (age>30 AND score<50)",
        };
    }

    public EngineBaseResult RunGraphNodeScan(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warm-up
        RunFullScan("_concepts");

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        var count = RunFullScan("_concepts");

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMicroseconds(), 0),
            Allocation = FormatAlloc(allocAfter - allocBefore),
            Note = $"{count} nodes scanned",
        };
    }

    public EngineBaseResult RunGraphEdgeScan(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warm-up
        RunFullScan("_relations");

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        var count = RunFullScan("_relations");

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMicroseconds(), 0),
            Allocation = FormatAlloc(allocAfter - allocBefore),
            Note = $"{count} edges scanned",
        };
    }

    public EngineBaseResult RunGraphSeek()
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        var rowCount = GetRowCount("_concepts");
        var targetRowId = Math.Max(1, rowCount / 2);

        // Warm-up
        RunSeek("_concepts", targetRowId);

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        RunSeek("_concepts", targetRowId);

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalNanoseconds(), 0),
            Allocation = FormatAlloc(allocAfter - allocBefore),
            Note = $"Seek to rowid {targetRowId}",
        };
    }

    public EngineBaseResult RunGraphTraverse()
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warm-up
        RunBfs(1);

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        var (hop1Count, hop2Count) = RunBfs(1);

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMicroseconds(), 0),
            Allocation = FormatAlloc(allocAfter - allocBefore),
            Note = $"2-hop BFS: {hop1Count} + {hop2Count} nodes (SQL WHERE)",
        };
    }

    public EngineBaseResult RunGcPressure(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warm-up
        RunColumnScan("users", "id");

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        var count = RunColumnScan("users", "id");

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMilliseconds, 1),
            Allocation = FormatAlloc(allocAfter - allocBefore),
            Note = $"{count} rows, sustained integer scan",
        };
    }

    public EngineBaseResult RunEncryption()
    {
        return new EngineBaseResult
        {
            NotSupported = true,
            Note = "Microsoft.Data.Sqlite does not support encryption",
        };
    }

    public EngineBaseResult RunMemoryFootprint()
    {
        if (_dbBytes is null) return new EngineBaseResult { Value = null, Note = "No data" };

        return new EngineBaseResult
        {
            Value = Math.Round(_dbBytes.Length / 1024.0, 0),
            Allocation = $"{_dbBytes.Length / 1024.0:F0} KB (SQLite file)",
            Note = "SQLitePCLRaw e_sqlite3 WASM + database file",
        };
    }

    public EngineBaseResult RunPrimitives()
    {
        return new EngineBaseResult
        {
            NotSupported = true,
            Note = "No raw primitive parsing in SQL engine",
        };
    }

    /// <summary>Disposes the current connection, ready for re-init at different scale.</summary>
    public void Reset()
    {
        Cleanup();
        _dbBytes = null;
    }

    public void Dispose()
    {
        Cleanup();
    }

    // -- Internal query helpers --

    private (int TableCount, int ColumnCount) RunSchemaQuery()
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = "SELECT name, sql FROM sqlite_master WHERE type='table'";
        using var reader = cmd.ExecuteReader();
        int tableCount = 0;
        int columnCount = 0;
        while (reader.Read())
        {
            tableCount++;
            var sql = reader.GetString(1);
            // Count commas in CREATE TABLE as rough column count
            columnCount += sql.Split(',').Length;
        }
        return (tableCount, columnCount);
    }

    private long RunFullScan(string table)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = $"SELECT * FROM [{table}]";
        using var reader = cmd.ExecuteReader();
        long count = 0;
        var fieldCount = reader.FieldCount;
        while (reader.Read())
        {
            for (int i = 0; i < fieldCount; i++)
            {
                if (!reader.IsDBNull(i))
                    _ = reader.GetValue(i);
            }
            count++;
        }
        return count;
    }

    private bool RunSeek(string table, long rowId)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = $"SELECT * FROM [{table}] WHERE rowid = $id";
        cmd.Parameters.AddWithValue("$id", rowId);
        using var reader = cmd.ExecuteReader();
        if (reader.Read())
        {
            _ = reader.GetValue(0);
            return true;
        }
        return false;
    }

    private long RunColumnScan(string table, string column)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = $"SELECT [{column}] FROM [{table}]";
        using var reader = cmd.ExecuteReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetValue(0);
            count++;
        }
        return count;
    }

    private (long NullCount, long TotalCount) RunNullCount(string table, string column)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = $"SELECT [{column}] FROM [{table}]";
        using var reader = cmd.ExecuteReader();
        long nullCount = 0;
        long totalCount = 0;
        while (reader.Read())
        {
            if (reader.IsDBNull(0)) nullCount++;
            totalCount++;
        }
        return (nullCount, totalCount);
    }

    private long RunFilteredQuery(string sql)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;
        using var reader = cmd.ExecuteReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetValue(0);
            count++;
        }
        return count;
    }

    private (int Hop1, int Hop2) RunBfs(long startKey)
    {
        // Hop 1: edges from startKey
        var hop1Targets = new HashSet<long>();
        using (var cmd = _connection!.CreateCommand())
        {
            cmd.CommandText = "SELECT target_key FROM _relations WHERE source_key = $sourceKey";
            cmd.Parameters.AddWithValue("$sourceKey", startKey);
            using var reader = cmd.ExecuteReader();
            while (reader.Read())
                hop1Targets.Add(reader.GetInt64(0));
        }

        // Hop 2: edges from each hop-1 target
        var hop2Count = 0;
        using (var cmd = _connection!.CreateCommand())
        {
            cmd.CommandText = "SELECT COUNT(*) FROM _relations WHERE source_key = $sourceKey";
            var pSourceKey = cmd.Parameters.Add("$sourceKey", SqliteType.Integer);
            cmd.Prepare();

            foreach (var target in hop1Targets)
            {
                pSourceKey.Value = target;
                hop2Count += Convert.ToInt32(cmd.ExecuteScalar());
            }
        }

        return (hop1Targets.Count, hop2Count);
    }

    private long GetRowCount(string table)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = $"SELECT COUNT(*) FROM [{table}]";
        return Convert.ToInt64(cmd.ExecuteScalar());
    }

    private void Cleanup()
    {
        if (_connection is not null)
        {
            _connection.Close();
            _connection.Dispose();
            _connection = null;
        }
        if (_tempPath is not null)
        {
            try { File.Delete(_tempPath); } catch { /* ignore */ }
            _tempPath = null;
        }
    }

    private static string FormatAlloc(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        if (bytes < 1024 * 1024) return $"{bytes / 1024.0:F1} KB";
        return $"{bytes / (1024.0 * 1024.0):F1} MB";
    }
}