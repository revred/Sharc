// Copyright (c) Ram Revanur. All rights reserved.
// Licensed under the MIT License.


using System.Diagnostics;
using Microsoft.Data.Sqlite;
using Sharc.Arena.Wasm.Models;

namespace Sharc.Arena.Wasm.Services;

/// <summary>
/// Tier 1 live engine: runs Microsoft.Data.Sqlite directly in .NET WASM.
/// Same runtime as Sharc — identical timing (Stopwatch + GC alloc tracking).
/// SQLitePCLRaw bundles e_sqlite3 compiled to WASM via Emscripten, accessed via P/Invoke.
///
/// Methodology: matches SharcEngine exactly — same warmup counts, iteration counts,
/// column projections, and typed column reads for a fair comparison.
/// </summary>
public sealed class SqliteEngine : IDisposable
{
    private SqliteConnection? _connection;
    private byte[]? _dbBytes;
    private string? _tempPath;

    /// <summary>Exposes the live connection for query pipeline execution.</summary>
    internal SqliteConnection? Connection => _connection;

    /// <summary>
    /// Ensures the database is opened from pre-generated bytes.
    /// Accepts pre-generated byte[] to avoid redundant DataGenerator runs.
    /// </summary>
    public (double Ms, long AllocBytes) EnsureInitialized(byte[] dbBytes)
    {
        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        Cleanup();

        _dbBytes = dbBytes;
        _tempPath = Path.GetTempFileName();
        File.WriteAllBytes(_tempPath, _dbBytes);

        _connection = new SqliteConnection($"Data Source={_tempPath};Mode=ReadOnly");
        _connection.Open();

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();
        return (sw.Elapsed.TotalMilliseconds, allocAfter - allocBefore);
    }

    public EngineBaseResult RunEngineLoad()
    {
        if (_dbBytes is null) return new EngineBaseResult { Value = null, Note = "No data" };

        // Re-open: measure just the connection open from file bytes
        Cleanup();

        _tempPath = Path.GetTempFileName();
        File.WriteAllBytes(_tempPath, _dbBytes);

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        _connection = new SqliteConnection($"Data Source={_tempPath};Mode=ReadOnly");
        _connection.Open();

        // Force schema load (sqlite reads header + schema on first query)
        using var cmd = _connection.CreateCommand();
        cmd.CommandText = "SELECT COUNT(*) FROM sqlite_master";
        _ = cmd.ExecuteScalar();

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();
        var allocKb = (allocAfter - allocBefore) / 1024.0;

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMilliseconds * 1000.0, 1),
            Allocation = $"{allocKb:F1} KB",
            Note = "Microsoft.Data.Sqlite — in-process P/Invoke",
        };
    }

    // ── SchemaRead: 50 warmup, 100 measured (matches Sharc) ──

    public EngineBaseResult RunSchemaRead()
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warmup: 50 iterations (matches Sharc's WASM JIT warmup)
        for (int i = 0; i < 50; i++) RunSchemaQuery();

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        const int iterations = 100;
        var (tableCount, columnCount) = (0, 0);
        for (int i = 0; i < iterations; i++)
            (tableCount, columnCount) = RunSchemaQuery();

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMicroseconds() / iterations, 1),
            Allocation = FormatAlloc((allocAfter - allocBefore) / iterations),
            Note = $"{tableCount} tables (avg of {iterations})",
        };
    }

    // ── SequentialScan: 1 warmup, 2 measured, 7 typed columns (matches Sharc) ──

    public EngineBaseResult RunSequentialScan(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warmup with typed column reads
        RunProjectedScan();

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        long rowCount = 0;
        const int iterations = 2;
        for (int run = 0; run < iterations; run++)
            rowCount = RunProjectedScan();

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMilliseconds / iterations, 2),
            Allocation = FormatAlloc((allocAfter - allocBefore) / iterations),
            Note = $"{rowCount} rows (column projection, avg of {iterations})",
        };
    }

    // ── PointLookup: 100 warmup, 1000 measured, 2 typed columns (matches Sharc) ──

    public EngineBaseResult RunPointLookup()
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        var rowCount = GetRowCount("users");
        var targetId = Math.Max(1, rowCount / 2);

        using var cmd = _connection.CreateCommand();
        cmd.CommandText = "SELECT id, name FROM users WHERE rowid = $id";
        var pId = cmd.Parameters.Add("$id", SqliteType.Integer);
        cmd.Prepare();

        // Warmup: 100 iterations
        for (int i = 0; i < 100; i++)
        {
            pId.Value = targetId;
            using var r = cmd.ExecuteReader();
            if (r.Read()) { _ = r.GetInt64(0); _ = r.GetString(1); }
        }

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        const int iterations = 1000;
        bool found = false;
        for (int i = 0; i < iterations; i++)
        {
            pId.Value = targetId;
            using var r = cmd.ExecuteReader();
            if (r.Read())
            {
                _ = r.GetInt64(0);
                _ = r.GetString(1);
                found = true;
            }
        }

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalNanoseconds() / iterations, 0),
            Allocation = FormatAlloc((allocAfter - allocBefore) / iterations),
            Note = $"rowid={targetId}, found={found} (avg of {iterations})",
        };
    }

    // ── BatchLookup: 100 warmup, 500 outer × batchSize inner (matches Sharc) ──

    public EngineBaseResult RunBatchLookup(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        var rowCount = GetRowCount("users");
        var batchSize = Math.Max(1, (int)(6 * scale));
        var rng = new Random(42); // same seed as Sharc

        using var cmd = _connection.CreateCommand();
        cmd.CommandText = "SELECT id, name FROM users WHERE rowid = $id";
        var pId = cmd.Parameters.Add("$id", SqliteType.Integer);
        cmd.Prepare();

        // Warmup: 100 seeks
        for (int i = 0; i < 100; i++)
        {
            pId.Value = 1L;
            using var r = cmd.ExecuteReader();
            if (r.Read()) { _ = r.GetInt64(0); _ = r.GetString(1); }
        }

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        const int iterations = 500;
        for (int j = 0; j < iterations; j++)
        {
            for (int i = 0; i < batchSize; i++)
            {
                pId.Value = rng.NextInt64(1, rowCount + 1);
                using var r = cmd.ExecuteReader();
                if (r.Read())
                {
                    _ = r.GetInt64(0);
                    _ = r.GetString(1);
                }
            }
        }

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalNanoseconds() / iterations, 0),
            Allocation = FormatAlloc((allocAfter - allocBefore) / iterations),
            Note = $"Batch of {batchSize} seeks (avg of {iterations})",
        };
    }

    // ── TypeDecode: 3 warmup, 3 measured (matches Sharc) ──

    public EngineBaseResult RunTypeDecode(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warmup: 3 passes
        for (int w = 0; w < 3; w++) RunTypedColumnScan("users", "id");

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        long count = 0;
        const int iterations = 3;
        for (int run = 0; run < iterations; run++)
            count = RunTypedColumnScan("users", "id");

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMilliseconds / iterations, 2),
            Allocation = FormatAlloc((allocAfter - allocBefore) / iterations),
            Note = $"{count} integers decoded (avg of {iterations})",
        };
    }

    // ── NullScan: 3 warmup, 3 measured (matches Sharc) ──

    public EngineBaseResult RunNullScan(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warmup: 3 passes
        for (int w = 0; w < 3; w++) RunNullCount("users", "bio");

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        long nullCount = 0, totalCount = 0;
        const int iterations = 3;
        for (int run = 0; run < iterations; run++)
            (nullCount, totalCount) = RunNullCount("users", "bio");

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMicroseconds() / iterations, 0),
            Allocation = FormatAlloc((allocAfter - allocBefore) / iterations),
            Note = $"{nullCount}/{totalCount} nulls (avg of {iterations})",
        };
    }

    // ── WhereFilter: 3 warmup, 3 measured, projected id column (matches Sharc) ──

    public EngineBaseResult RunWhereFilter(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warmup: 3 passes
        for (int w = 0; w < 3; w++) RunProjectedFilter();

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        long matchCount = 0;
        const int iterations = 3;
        for (int run = 0; run < iterations; run++)
            matchCount = RunProjectedFilter();

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMilliseconds / iterations, 2),
            Allocation = FormatAlloc((allocAfter - allocBefore) / iterations),
            Note = $"{matchCount} matches (avg of {iterations})",
        };
    }

    // ── GraphNodeScan: 1 warmup, 1 measured, 4 typed columns (matches Sharc) ──

    public EngineBaseResult RunGraphNodeScan(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warmup
        RunProjectedNodeScan();

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        var count = RunProjectedNodeScan();

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMicroseconds(), 0),
            Allocation = FormatAlloc(allocAfter - allocBefore),
            Note = $"{count} nodes scanned",
        };
    }

    // ── GraphEdgeScan: 1 warmup, 1 measured, 4 typed columns (matches Sharc) ──

    public EngineBaseResult RunGraphEdgeScan(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warmup
        RunProjectedEdgeScan();

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        var count = RunProjectedEdgeScan();

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMicroseconds(), 0),
            Allocation = FormatAlloc(allocAfter - allocBefore),
            Note = $"{count} edges scanned",
        };
    }

    // ── GraphSeek: 100 warmup, 1000 measured, 3 typed columns (matches Sharc) ──

    public EngineBaseResult RunGraphSeek()
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        var rowCount = GetRowCount("_concepts");
        var targetRowId = Math.Max(1, rowCount / 2);

        using var cmd = _connection.CreateCommand();
        cmd.CommandText = "SELECT id, key, data FROM _concepts WHERE rowid = $id";
        var pId = cmd.Parameters.Add("$id", SqliteType.Integer);
        cmd.Prepare();

        // Warmup: 100 iterations
        for (int i = 0; i < 100; i++)
        {
            pId.Value = targetRowId;
            using var r = cmd.ExecuteReader();
            if (r.Read()) { _ = r.GetString(0); _ = r.GetInt64(1); _ = r.GetString(2); }
        }

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        const int iterations = 1000;
        for (int i = 0; i < iterations; i++)
        {
            pId.Value = targetRowId;
            using var r = cmd.ExecuteReader();
            if (r.Read())
            {
                _ = r.GetString(0);  // id
                _ = r.GetInt64(1);   // key
                _ = r.GetString(2);  // data
            }
        }

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalNanoseconds() / iterations, 0),
            Allocation = FormatAlloc((allocAfter - allocBefore) / iterations),
            Note = $"Seek to rowid {targetRowId} (avg of {iterations})",
        };
    }

    // ── GraphTraverse: 5 warmup, 5 measured (matches Sharc) ──

    public EngineBaseResult RunGraphTraverse()
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warmup: 5 passes
        for (int w = 0; w < 5; w++) RunBfs(1);

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        const int iterations = 5;
        int hop1Count = 0, hop2Count = 0;
        for (int run = 0; run < iterations; run++)
            (hop1Count, hop2Count) = RunBfs(1);

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMicroseconds() / iterations, 0),
            Allocation = FormatAlloc((allocAfter - allocBefore) / iterations),
            Note = $"2-hop BFS: {hop1Count} + {hop2Count} nodes (avg of {iterations})",
        };
    }

    // ── GcPressure: 1 warmup, 1 measured (already matches Sharc) ──

    public EngineBaseResult RunGcPressure(double scale)
    {
        if (_connection is null) return new EngineBaseResult { Value = null, Note = "Not initialized" };

        // Warmup
        RunTypedColumnScan("users", "id");

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        var sw = Stopwatch.StartNew();

        var count = RunTypedColumnScan("users", "id");

        sw.Stop();
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();

        return new EngineBaseResult
        {
            Value = Math.Round(sw.Elapsed.TotalMilliseconds, 1),
            Allocation = FormatAlloc(allocAfter - allocBefore),
            Note = $"{count} rows, sustained integer scan",
        };
    }

    public EngineBaseResult RunEncryption()
    {
        return new EngineBaseResult
        {
            NotSupported = true,
            Note = "Microsoft.Data.Sqlite does not support encryption",
        };
    }

    public EngineBaseResult RunMemoryFootprint()
    {
        if (_dbBytes is null) return new EngineBaseResult { Value = null, Note = "No data" };

        var allocBefore = GC.GetAllocatedBytesForCurrentThread();
        using (var probe = new SqliteConnection($"Data Source={_tempPath};Mode=ReadOnly"))
        {
            probe.Open();
            using var cmd = probe.CreateCommand();
            cmd.CommandText = "SELECT COUNT(*) FROM sqlite_master";
            _ = cmd.ExecuteScalar();
        }
        var allocAfter = GC.GetAllocatedBytesForCurrentThread();
        var managedOverheadKb = (allocAfter - allocBefore) / 1024.0;

        var baseSizeKb = _dbBytes.Length / 1024.0;
        var totalKb = baseSizeKb + managedOverheadKb;

        return new EngineBaseResult
        {
            Value = Math.Round(totalKb, 0),
            Allocation = $"{totalKb:F0} KB (WASM binary + heap)",
            Note = "e_sqlite3.wasm (1.5MB) + managed overhead",
        };
    }

    public EngineBaseResult RunPrimitives()
    {
        return new EngineBaseResult
        {
            NotSupported = true,
            Note = "No raw primitive parsing in SQL engine",
        };
    }

    /// <summary>Disposes the current connection, ready for re-init at different scale.</summary>
    public void Reset()
    {
        Cleanup();
        _dbBytes = null;
    }

    public void Dispose()
    {
        Cleanup();
    }

    // ── Query helpers (typed reads, matching Sharc's column projections) ──

    private (int TableCount, int ColumnCount) RunSchemaQuery()
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = "SELECT name, sql FROM sqlite_master WHERE type='table'";
        using var reader = cmd.ExecuteReader();
        int tableCount = 0;
        int columnCount = 0;
        while (reader.Read())
        {
            tableCount++;
            var sql = reader.GetString(1);
            columnCount += sql.Split(',').Length;
        }
        return (tableCount, columnCount);
    }

    /// <summary>Projected scan: SELECT id,name,email,age,score,active,dept with typed reads.</summary>
    private long RunProjectedScan()
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = "SELECT id, name, email, age, score, active, dept FROM users";
        using var reader = cmd.ExecuteReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);     // id
            _ = reader.GetString(1);    // name
            _ = reader.GetString(2);    // email
            _ = reader.GetInt64(3);     // age
            _ = reader.GetDouble(4);    // score
            _ = reader.GetInt64(5);     // active
            _ = reader.GetString(6);    // dept
            count++;
        }
        return count;
    }

    /// <summary>Typed column scan: SELECT [column] with GetInt64.</summary>
    private long RunTypedColumnScan(string table, string column)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = $"SELECT [{column}] FROM [{table}]";
        using var reader = cmd.ExecuteReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    private (long NullCount, long TotalCount) RunNullCount(string table, string column)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = $"SELECT [{column}] FROM [{table}]";
        using var reader = cmd.ExecuteReader();
        long nullCount = 0;
        long totalCount = 0;
        while (reader.Read())
        {
            if (reader.IsDBNull(0)) nullCount++;
            totalCount++;
        }
        return (nullCount, totalCount);
    }

    /// <summary>WHERE filter with projected id column and typed read.</summary>
    private long RunProjectedFilter()
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = "SELECT id FROM users WHERE age > 30 AND score < 50";
        using var reader = cmd.ExecuteReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);
            count++;
        }
        return count;
    }

    /// <summary>4 typed columns: id, key, kind, data (matches Sharc's _concepts scan).</summary>
    private long RunProjectedNodeScan()
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = "SELECT id, key, kind, data FROM _concepts";
        using var reader = cmd.ExecuteReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetString(0);  // id
            _ = reader.GetInt64(1);   // key
            _ = reader.GetInt64(2);   // kind
            _ = reader.GetString(3);  // data
            count++;
        }
        return count;
    }

    /// <summary>4 typed columns: source_key, target_key, kind, data (matches Sharc's _relations scan).</summary>
    private long RunProjectedEdgeScan()
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = "SELECT source_key, target_key, kind, data FROM _relations";
        using var reader = cmd.ExecuteReader();
        long count = 0;
        while (reader.Read())
        {
            _ = reader.GetInt64(0);   // source_key
            _ = reader.GetInt64(1);   // target_key
            _ = reader.GetInt64(2);   // kind
            _ = reader.GetString(3);  // data
            count++;
        }
        return count;
    }

    private (int Hop1, int Hop2) RunBfs(long startKey)
    {
        var hop1Targets = new HashSet<long>();
        using (var cmd = _connection!.CreateCommand())
        {
            cmd.CommandText = "SELECT target_key FROM _relations WHERE source_key = $sourceKey";
            cmd.Parameters.AddWithValue("$sourceKey", startKey);
            using var reader = cmd.ExecuteReader();
            while (reader.Read())
                hop1Targets.Add(reader.GetInt64(0));
        }

        var hop2Count = 0;
        using (var cmd = _connection!.CreateCommand())
        {
            cmd.CommandText = "SELECT COUNT(*) FROM _relations WHERE source_key = $sourceKey";
            var pSourceKey = cmd.Parameters.Add("$sourceKey", SqliteType.Integer);
            cmd.Prepare();

            foreach (var target in hop1Targets)
            {
                pSourceKey.Value = target;
                hop2Count += Convert.ToInt32(cmd.ExecuteScalar());
            }
        }

        return (hop1Targets.Count, hop2Count);
    }

    private long GetRowCount(string table)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = $"SELECT COUNT(*) FROM [{table}]";
        return Convert.ToInt64(cmd.ExecuteScalar());
    }

    private void Cleanup()
    {
        if (_connection is not null)
        {
            _connection.Close();
            _connection.Dispose();
            _connection = null;
        }
        if (_tempPath is not null)
        {
            try { File.Delete(_tempPath); } catch { /* ignore */ }
            _tempPath = null;
        }
    }

    private static string FormatAlloc(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        if (bytes < 1024 * 1024) return $"{bytes / 1024.0:F1} KB";
        return $"{bytes / (1024.0 * 1024.0):F1} MB";
    }
}
