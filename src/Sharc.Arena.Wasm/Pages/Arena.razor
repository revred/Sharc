@page "/"
@using System.Diagnostics
@inject BenchmarkDataLoader DataLoader
@inject IJSRuntime JS

<div class="arena-bg-gradient"></div>
<div class="arena-bg-grid"></div>

@if (!_loaded)
{
    <div class="arena-loading">Loading benchmark data...</div>
}
else
{
<PageNav ActivePage="@_activePage" OnNavigate="@NavigateToPage" />

<div class="arena-pages">
    @* ── Page 1: Hook ── *@
    <section id="page-hook" class="arena-page">
        <HookPage OnNavigate="@NavigateToPage" />
    </section>

    @* ── Page 2: Context Problem ── *@
    <section id="page-context" class="arena-page">
        <ContextProblemPage />
    </section>

    @* ── Page 3: Benchmark Arena ── *@
    <section id="page-benchmarks" class="arena-page">
        <div class="arena-container @(_isMobile ? "mobile" : "")">
            <ArenaHeader
                Slides="@_slides"
                Engines="@_engines"
                Preset="@_preset"
                Presets="@_presets"
                State="@_state"
                DoneCount="@_doneSlides.Count"
                ElapsedMs="@_elapsedMs"
                IsLive="@_isLive"
                OnLiveToggle="@(live => _isLive = live)"
                OnPresetChange="@ApplyPreset"
                OnRun="@RunAll"
                OnStop="@Stop" />

            @if (_isMobile && _state != BenchmarkState.Idle)
            {
                <ProgressDots Slides="@_slides" CurrentIndex="@_currentIndex" DoneSlides="@_doneSlides" />
            }

            <div class="arena-layout @(_showSidebar ? "with-sidebar" : "")">
                @if (_showSidebar)
                {
                    <aside class="arena-sidebar">
                        <SideNav
                            Slides="@_slides"
                            CurrentIndex="@_currentIndex"
                            DoneSlides="@_doneSlides"
                            Running="@(_state == BenchmarkState.Running)"
                            OnJump="@JumpToSlide"
                            Categories="@_categories" />
                    </aside>
                }

                <main class="arena-main">
                    @for (var i = 0; i < _slides.Count; i++)
                    {
                        var index = i;
                        var slide = _slides[i];
                        <div id="slide-@slide.Id">
                            <SlideCard
                                Slide="@slide"
                                Data="@GetSlideResults(slide.Id)"
                                IsActive="@(_currentIndex == index)"
                                IsDone="@_doneSlides.Contains(slide.Id)"
                                Number="@(index + 1)"
                                Total="@_slides.Count"
                                IsMobile="@_isMobile"
                                TileDensity="@GetTileDensity(slide.Id)"
                                OnDensityChange="@(densityId => SetTileDensity(slide.Id, densityId))"
                                Running="@(_state == BenchmarkState.Running)"
                                Engines="@_engines"
                                Categories="@_categories" />
                        </div>
                    }

                    @if (_state == BenchmarkState.Done)
                    {
                        <Scoreboard Results="@_results" Slides="@_slides" Engines="@_engines" />
                    }
                </main>
            </div>
        </div>
    </section>

    @* ── Page 4: Query Pipeline ── *@
    <section id="page-pipeline" class="arena-page">
        <QueryPipelinePage />
    </section>

    @* ── Page 5: Trust Demo ── *@
    <section id="page-trust" class="arena-page">
        <TrustDemoPage />
    </section>

    @* ── Page 6: Honest Comparison ── *@
    <section id="page-honest" class="arena-page">
        <HonestComparisonPage />
    </section>

    @* ── Page 7: CTA ── *@
    <section id="page-cta" class="arena-page">
        <CtaPage />
    </section>
</div>
}

@code {
    [Inject] private BenchmarkRunner LiveEngine { get; set; } = default!;
    [Inject] private ReferenceEngine StaticEngine { get; set; } = default!;

    private bool _loaded;
    private string _activePage = "page-hook";
    private IReadOnlyList<SlideDefinition> _slides = [];
    private IReadOnlyList<EngineDefinition> _engines = [];
    private IReadOnlyList<Preset> _presets = [];
    private IReadOnlyList<Category> _categories = [];
    private string _preset = "quick";
    private BenchmarkState _state = BenchmarkState.Idle;
    private int _currentIndex = -1;
    private bool _isLive = true;
    private HashSet<string> _doneSlides = new();
    private Dictionary<string, IReadOnlyDictionary<string, EngineBaseResult>> _results = new();
    private Dictionary<string, string> _tileDensities = new();
    private double _elapsedMs;
    private CancellationTokenSource? _cts;
    private bool _isMobile;
    private bool _showSidebar;

    protected override async Task OnInitializedAsync()
    {
        _engines = await DataLoader.LoadEnginesAsync();
        _categories = await DataLoader.LoadCategoriesAsync();
        _presets = await DataLoader.LoadPresetsAsync();
        _slides = await DataLoader.LoadAllSlidesAsync();
        _loaded = true;

        ApplyPreset("quick");
        UpdateLayout();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                var width = await JS.InvokeAsync<int>("viewportHelper.getWidth");
                _isMobile = width < 768;
                _showSidebar = !_isMobile;
                StateHasChanged();
            }
            catch
            {
                // JS not available during prerender
            }
        }
    }

    [JSInvokable]
    public void OnPageVisible(string pageId)
    {
        _activePage = pageId;
        StateHasChanged();
    }

    private async Task NavigateToPage(string pageId)
    {
        _activePage = pageId;
        try
        {
            await JS.InvokeVoidAsync("viewportHelper.scrollToElement", pageId);
        }
        catch
        {
            // Fallback: no-op
        }
    }

    private void UpdateLayout()
    {
        _isMobile = false;
        _showSidebar = true;
    }

    private void ApplyPreset(string presetId)
    {
        if (_state == BenchmarkState.Running) return;
        _preset = presetId;
        var preset = _presets.FirstOrDefault(p => p.Id == presetId);
        if (preset is null) return;

        var newDensities = new Dictionary<string, string>();
        foreach (var slide in _slides)
        {
            var tiers = slide.DensityTiers;
            if (tiers.Count <= 1)
            {
                newDensities[slide.Id] = tiers[0]?.Id ?? "md";
                continue;
            }

            var best = tiers[0];
            foreach (var tier in tiers)
            {
                if (Math.Abs(tier.Scale - preset.Scale) < Math.Abs(best.Scale - preset.Scale))
                    best = tier;
            }
            newDensities[slide.Id] = best.Id;
        }
        _tileDensities = newDensities;
    }

    private string GetTileDensity(string slideId)
    {
        if (_tileDensities.TryGetValue(slideId, out var d)) return d;
        var slide = _slides.FirstOrDefault(s => s.Id == slideId);
        return slide?.DefaultDensity ?? "md";
    }

    private void SetTileDensity(string slideId, string densityId)
    {
        if (_state == BenchmarkState.Running) return;
        _tileDensities[slideId] = densityId;
        StateHasChanged();
    }

    private double GetScaleForSlide(SlideDefinition slide)
    {
        var densityId = GetTileDensity(slide.Id);
        var tier = slide.DensityTiers.FirstOrDefault(t => t.Id == densityId);
        return tier?.Scale ?? 1.0;
    }

    private IReadOnlyDictionary<string, EngineBaseResult>? GetSlideResults(string slideId)
    {
        return _results.TryGetValue(slideId, out var r) ? r : null;
    }

    private async Task RunAll()
    {
        _cts?.Cancel();
        _cts = new CancellationTokenSource();
        var token = _cts.Token;

        _state = BenchmarkState.Running;
        _results.Clear();
        _doneSlides.Clear();
        _elapsedMs = 0;
        StateHasChanged();

        var sw = Stopwatch.StartNew();
        var activePreset = _presets.FirstOrDefault(p => p.Id == _preset)!;

        for (var i = 0; i < _slides.Count; i++)
        {
            if (token.IsCancellationRequested) break;

            var slide = _slides[i];
            _currentIndex = i;
            _elapsedMs = sw.Elapsed.TotalMilliseconds;
            StateHasChanged();

            // Transition delay
            await Task.Delay(activePreset.TransitionMs, token).ConfigureAwait(false);
            if (token.IsCancellationRequested) break;

            // Run benchmark
            var scale = GetScaleForSlide(slide);
            IBenchmarkEngine engine = _isLive ? LiveEngine : StaticEngine;
            var data = await engine.RunSlideAsync(slide, scale, token);

            _results[slide.Id] = data;
            _doneSlides.Add(slide.Id);
            _elapsedMs = sw.Elapsed.TotalMilliseconds;
            StateHasChanged();

            // Pause delay
            await Task.Delay(activePreset.PauseMs, token).ConfigureAwait(false);
        }

        sw.Stop();
        _elapsedMs = sw.Elapsed.TotalMilliseconds;
        _currentIndex = -1;
        _state = BenchmarkState.Done;
        StateHasChanged();
    }

    private void Stop()
    {
        _cts?.Cancel();
        _currentIndex = -1;
        _state = BenchmarkState.Done;
        StateHasChanged();
    }

    private void JumpToSlide(int index)
    {
        // Scroll handled by JS interop in the future; for now just a no-op
    }
}
