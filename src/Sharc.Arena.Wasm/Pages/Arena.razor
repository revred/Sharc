@page "/"
@using System.Diagnostics
@inject BenchmarkDataLoader DataLoader
@inject IJSRuntime JS

<div class="arena-bg-gradient"></div>
<div class="arena-bg-grid"></div>

@if (!_loaded)
{
    <div class="arena-loading">
        <div class="loading-title">Initializing Engines</div>

        <div class="loading-race">
            <div class="loading-engine @(_loadPhase >= 2 ? "done" : _loadPhase == 1 ? "active" : "")">
                <span class="loading-engine-icon">&#x1F988;</span>
                <div class="loading-engine-info">
                    <span class="loading-engine-name">Sharc <span class="loading-engine-size">50 KB</span></span>
                    @if (_loadPhase >= 2)
                    {
                        <span class="loading-engine-time">@($"{_sharcInitMs:F2}")ms &middot; @FormatBytes(_sharcInitAlloc)</span>
                    }
                    else if (_loadPhase == 1)
                    {
                        <span class="loading-engine-time loading-pulse">loading...</span>
                    }
                </div>
                @if (_loadPhase >= 2) { <span class="loading-check">&#x2713;</span> }
            </div>

            <div class="loading-engine @(_loadPhase >= 4 ? (_sqliteError is null ? "done" : "error") : _loadPhase == 3 ? "active" : "")">
                <span class="loading-engine-icon">&#x26A1;</span>
                <div class="loading-engine-info">
                    <span class="loading-engine-name">SQLite <span class="loading-engine-size">1.5 MB</span></span>
                    @if (_loadPhase >= 4 && _sqliteError is null)
                    {
                        <span class="loading-engine-time">@($"{_sqliteInitMs:F1}")ms &middot; @FormatBytes(_sqliteInitAlloc)</span>
                    }
                    else if (_loadPhase >= 4 && _sqliteError is not null)
                    {
                        <span class="loading-engine-time" style="color:#f87171;">WASM native init failed</span>
                    }
                    else if (_loadPhase == 3)
                    {
                        <span class="loading-engine-time loading-pulse">loading...</span>
                    }
                </div>
                @if (_loadPhase >= 4 && _sqliteError is null) { <span class="loading-check">&#x2713;</span> }
                @if (_loadPhase >= 4 && _sqliteError is not null) { <span class="loading-check" style="color:#f87171;">&#x2717;</span> }
            </div>
        </div>

        @if (_loadPhase >= 4)
        {
            <div class="loading-verdict">
                @if (_sqliteError is null)
                {
                    var ratio = _sqliteInitMs / Math.Max(0.001, _sharcInitMs);
                    <span>Sharc loaded <strong>@($"{ratio:F0}x faster")</strong></span>
                }
                else
                {
                    <span style="color:#fbbf24;font-size:0.75rem;">@_sqliteError</span>
                }
            </div>
        }

        @if (_loadPhase >= 5)
        {
            <div class="loading-ready">Ready</div>
        }
    </div>
}
else
{
<PageNav ActivePage="@_activePage" OnNavigate="@NavigateToPage" />

<div class="arena-pages">
    @* ── Page 1: Hook ── *@
    <section id="page-hook" class="arena-page">
        <HookPage OnNavigate="@NavigateToPage" />
    </section>

    @* ── Page 2: Context Problem ── *@
    <section id="page-context" class="arena-page">
        <ContextProblemPage />
    </section>

    @* ── Page 3: Benchmark Arena ── *@
    <section id="page-benchmarks" class="arena-page">
        <div class="arena-container @(_isMobile ? "mobile" : "")">
            <ArenaHeader
                Slides="@_slides"
                Engines="@_engines"
                Preset="@_preset"
                Presets="@_presets"
                State="@_state"
                DoneCount="@_doneSlides.Count"
                ElapsedMs="@_elapsedMs"
                IsLive="@_isLive"
                OnLiveToggle="@(live => _isLive = live)"
                OnPresetChange="@ApplyPreset"
                OnRun="@RunAll"
                OnStop="@Stop" />

            @if (_isMobile && _state != BenchmarkState.Idle)
            {
                <ProgressDots Slides="@_slides" CurrentIndex="@_currentIndex" DoneSlides="@_doneSlides" />
            }

            <div class="arena-layout @(_showSidebar ? "with-sidebar" : "")">
                @if (_showSidebar)
                {
                    <aside class="arena-sidebar">
                        <SideNav
                            Slides="@_slides"
                            CurrentIndex="@_currentIndex"
                            DoneSlides="@_doneSlides"
                            Running="@(_state == BenchmarkState.Running)"
                            OnJump="@JumpToSlide"
                            Categories="@_categories" />
                    </aside>
                }

                <main class="arena-main">
                    @for (var i = 0; i < _slides.Count; i++)
                    {
                        var index = i;
                        var slide = _slides[i];
                        <div id="slide-@slide.Id">
                            <SlideCard
                                Slide="@slide"
                                Data="@GetSlideResults(slide.Id)"
                                IsActive="@(_currentIndex == index)"
                                IsDone="@_doneSlides.Contains(slide.Id)"
                                Number="@(index + 1)"
                                Total="@_slides.Count"
                                IsMobile="@_isMobile"
                                TileDensity="@GetTileDensity(slide.Id)"
                                OnDensityChange="@(densityId => SetTileDensity(slide.Id, densityId))"
                                Running="@(_state == BenchmarkState.Running)"
                                Engines="@_engines"
                                Categories="@_categories" />
                        </div>
                    }

                    @if (_state == BenchmarkState.Done)
                    {
                        <Scoreboard Results="@_results" Slides="@_slides" Engines="@_engines" />
                    }
                </main>
            </div>
        </div>
    </section>

    @* ── Page 4: Query Pipeline ── *@
    <section id="page-pipeline" class="arena-page">
        <QueryPipelinePage />
    </section>

    @* ── Page 5: SQL Playground ── *@
    <section id="page-playground" class="arena-page">
        <SqlPlaygroundPage />
    </section>

    @* ── Page 6: Trust Demo ── *@
    <section id="page-trust" class="arena-page">
        <TrustDemoPage />
    </section>

    @* ── Page 7: Honest Comparison ── *@
    <section id="page-honest" class="arena-page">
        <HonestComparisonPage />
    </section>

    @* ── Page 8: CTA ── *@
    <section id="page-cta" class="arena-page">
        <CtaPage />
    </section>
</div>
}

@code {
    [Inject] private BenchmarkRunner LiveEngine { get; set; } = default!;
    [Inject] private ReferenceEngine StaticEngine { get; set; } = default!;

    private bool _loaded;
    private int _loadPhase; // 0=pending, 1=sharc loading, 2=sharc done, 3=sqlite loading, 4=sqlite done, 5=ready
    private double _sharcInitMs;
    private long _sharcInitAlloc;
    private double _sqliteInitMs;
    private long _sqliteInitAlloc;
    private string? _sqliteError;
    private string _activePage = "page-hook";
    private IReadOnlyList<SlideDefinition> _slides = [];
    private IReadOnlyList<EngineDefinition> _engines = [];
    private IReadOnlyList<Preset> _presets = [];
    private IReadOnlyList<Category> _categories = [];
    private string _preset = "quick";
    private BenchmarkState _state = BenchmarkState.Idle;
    private int _currentIndex = -1;
    private bool _isLive = true;
    private HashSet<string> _doneSlides = new();
    private Dictionary<string, IReadOnlyDictionary<string, EngineBaseResult>> _results = new();
    private Dictionary<string, string> _tileDensities = new();
    private double _elapsedMs;
    private CancellationTokenSource? _cts;
    private bool _isMobile;
    private bool _showSidebar;

    protected override async Task OnInitializedAsync()
    {
        // Phase 0: Load benchmark metadata
        _engines = await DataLoader.LoadEnginesAsync();
        _categories = await DataLoader.LoadCategoriesAsync();
        _presets = await DataLoader.LoadPresetsAsync();
        _slides = await DataLoader.LoadAllSlidesAsync();

        // Phase 1-4: Timed cold start — generate DB, init each engine, show results
        _loadPhase = 1;
        StateHasChanged();
        await Task.Yield(); // flush UI

        try
        {
            var coldStart = LiveEngine.TimeColdStart();

            _sharcInitMs = coldStart.SharcMs;
            _sharcInitAlloc = coldStart.SharcAlloc;
            _loadPhase = 2;
            StateHasChanged();
            await Task.Yield();

            _sqliteInitMs = coldStart.SqliteMs;
            _sqliteInitAlloc = coldStart.SqliteAlloc;
            _loadPhase = 4;
            StateHasChanged();
            await Task.Delay(600); // let user see the result
        }
        catch (Exception ex)
        {
            // SQLite native init can fail in WASM — proceed with Arena anyway
            _sqliteError = $"{ex.GetType().Name}: {ex.Message}";
            if (ex.InnerException is not null)
                _sqliteError += $" → {ex.InnerException.GetType().Name}: {ex.InnerException.Message}";
            _loadPhase = 4;
            StateHasChanged();
            await Task.Delay(600);
        }

        _loadPhase = 5;
        StateHasChanged();
        await Task.Delay(400); // brief "Ready" flash

        _loaded = true;
        ApplyPreset("quick");
        UpdateLayout();
    }

    private static string FormatBytes(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        if (bytes < 1024 * 1024) return $"{bytes / 1024.0:F1} KB";
        return $"{bytes / (1024.0 * 1024.0):F1} MB";
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                var width = await JS.InvokeAsync<int>("viewportHelper.getWidth");
                _isMobile = width < 768;
                _showSidebar = !_isMobile;
                StateHasChanged();
            }
            catch
            {
                // JS not available during prerender
            }
        }
    }

    [JSInvokable]
    public void OnPageVisible(string pageId)
    {
        _activePage = pageId;
        StateHasChanged();
    }

    private async Task NavigateToPage(string pageId)
    {
        _activePage = pageId;
        try
        {
            await JS.InvokeVoidAsync("viewportHelper.scrollToElement", pageId);
        }
        catch
        {
            // Fallback: no-op
        }
    }

    private void UpdateLayout()
    {
        _isMobile = false;
        _showSidebar = true;
    }

    private void ApplyPreset(string presetId)
    {
        if (_state == BenchmarkState.Running) return;
        _preset = presetId;
        var preset = _presets.FirstOrDefault(p => p.Id == presetId);
        if (preset is null) return;

        var newDensities = new Dictionary<string, string>();
        foreach (var slide in _slides)
        {
            var tiers = slide.DensityTiers;
            if (tiers.Count <= 1)
            {
                newDensities[slide.Id] = tiers[0]?.Id ?? "md";
                continue;
            }

            var best = tiers[0];
            foreach (var tier in tiers)
            {
                if (Math.Abs(tier.Scale - preset.Scale) < Math.Abs(best.Scale - preset.Scale))
                    best = tier;
            }
            newDensities[slide.Id] = best.Id;
        }
        _tileDensities = newDensities;
    }

    private string GetTileDensity(string slideId)
    {
        if (_tileDensities.TryGetValue(slideId, out var d)) return d;
        var slide = _slides.FirstOrDefault(s => s.Id == slideId);
        return slide?.DefaultDensity ?? "md";
    }

    private void SetTileDensity(string slideId, string densityId)
    {
        if (_state == BenchmarkState.Running) return;
        _tileDensities[slideId] = densityId;
        StateHasChanged();
    }

    private double GetScaleForSlide(SlideDefinition slide)
    {
        var densityId = GetTileDensity(slide.Id);
        var tier = slide.DensityTiers.FirstOrDefault(t => t.Id == densityId);
        return tier?.Scale ?? 1.0;
    }

    private IReadOnlyDictionary<string, EngineBaseResult>? GetSlideResults(string slideId)
    {
        return _results.TryGetValue(slideId, out var r) ? r : null;
    }

    private async Task RunAll()
    {
        _cts?.Cancel();
        _cts = new CancellationTokenSource();
        var token = _cts.Token;

        _state = BenchmarkState.Running;
        _results.Clear();
        _doneSlides.Clear();
        _elapsedMs = 0;
        StateHasChanged();

        var sw = Stopwatch.StartNew();
        var activePreset = _presets.FirstOrDefault(p => p.Id == _preset);
        if (activePreset is null) { await Stop(); return; }

        // JS-based timer for smooth stopwatch display.
        // Runs on the browser event loop — zero contention with .NET sync context.
        // The Task.Run + PeriodicTimer pattern caused intermittent stalls in WASM
        // because InvokeAsync(StateHasChanged) posted to the dispatcher queue,
        // competing with the main loop's continuations on the single thread.
        try { await JS.InvokeVoidAsync("arenaTimer.start"); } catch { }

        try
        {
            for (var i = 0; i < _slides.Count; i++)
            {
                if (token.IsCancellationRequested) break;

                var slide = _slides[i];
                _currentIndex = i;
                _elapsedMs = sw.Elapsed.TotalMilliseconds;
                StateHasChanged();
                await Task.Delay(1); // setTimeout(1) — yields to browser event loop, not just .NET scheduler

                try
                {
                    await Task.Delay(activePreset.TransitionMs, token);
                }
                catch (OperationCanceledException) { break; }
                if (token.IsCancellationRequested) break;

                // Update timer right before heavy work starts
                _elapsedMs = sw.Elapsed.TotalMilliseconds;
                StateHasChanged();
                await Task.Delay(1);

                // Run benchmark with 30s timeout to prevent indefinite hangs
                // (JS interop calls to IndexedDB can hang if the browser event loop is congested)
                try
                {
                    var scale = GetScaleForSlide(slide);
                    IBenchmarkEngine engine = _isLive ? LiveEngine : StaticEngine;
                    Console.WriteLine($"[Arena] [{i+1}/{_slides.Count}] Running {slide.Id} (scale={scale:F3}, live={_isLive})");

                    var slideTask = engine.RunSlideAsync(slide, scale, token);
                    var timeoutTask = Task.Delay(30_000);
                    var completed = await Task.WhenAny(slideTask, timeoutTask);

                    if (completed != slideTask)
                    {
                        Console.WriteLine($"[Arena] [{i+1}/{_slides.Count}] {slide.Id} TIMED OUT after 30s — skipping");
                        _doneSlides.Add(slide.Id);
                        _elapsedMs = sw.Elapsed.TotalMilliseconds;
                        StateHasChanged();
                        continue;
                    }

                    var data = await slideTask;
                    Console.WriteLine($"[Arena] [{i+1}/{_slides.Count}] {slide.Id} done");

                    _results[slide.Id] = data;
                    _doneSlides.Add(slide.Id);
                }
                catch (OperationCanceledException) { break; }
                catch (Exception ex)
                {
                    Console.WriteLine($"[Arena] Slide {slide.Id} failed: {ex.GetType().Name}: {ex.Message}");
                    _doneSlides.Add(slide.Id);
                }

                _elapsedMs = sw.Elapsed.TotalMilliseconds;
                StateHasChanged();

                try
                {
                    await Task.Delay(activePreset.PauseMs, token);
                }
                catch (OperationCanceledException) { break; }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[Arena] RunAll failed: {ex.GetType().Name}: {ex.Message}");
        }

        sw.Stop();
        try { await JS.InvokeVoidAsync("arenaTimer.stop"); } catch { }

        _elapsedMs = sw.Elapsed.TotalMilliseconds;
        _currentIndex = -1;
        _state = BenchmarkState.Done;
        StateHasChanged();
    }

    private async Task Stop()
    {
        _cts?.Cancel();
        try { await JS.InvokeVoidAsync("arenaTimer.stop"); } catch { }
        _currentIndex = -1;
        _state = BenchmarkState.Done;
        StateHasChanged();
    }

    private void JumpToSlide(int index)
    {
        // Scroll handled by JS interop in the future; for now just a no-op
    }
}
