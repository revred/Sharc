@* Final standings scoreboard shown after all benchmarks complete *@

@{
    // Calculate wins using only comparable slides (at least two engines supported).
    var scores = new Dictionary<string, (int Wins, int Supported, int Comparable)>();
    foreach (var e in Engines) scores[e.Id] = (0, 0, 0);

    foreach (var slide in Slides)
    {
        if (!Results.TryGetValue(slide.Id, out var data)) continue;

        var comparableEntries = new List<(string EngineId, double Value)>(Engines.Count);
        foreach (var e in Engines)
        {
            if (data.TryGetValue(e.Id, out var r) && !r.NotSupported && r.Value.HasValue)
            {
                var s = scores[e.Id];
                scores[e.Id] = (s.Wins, s.Supported + 1, s.Comparable);
                comparableEntries.Add((e.Id, r.Value.Value));
            }
        }

        if (comparableEntries.Count < 2) continue;

        foreach (var (engineId, _) in comparableEntries)
        {
            var s = scores[engineId];
            scores[engineId] = (s.Wins, s.Supported, s.Comparable + 1);
        }

        double bestVal = double.MaxValue;
        string? bestId = null;
        foreach (var (engineId, value) in comparableEntries)
        {
            if (value < bestVal)
            {
                bestVal = value;
                bestId = engineId;
            }
        }

        if (bestId != null)
        {
            var s = scores[bestId];
            scores[bestId] = (s.Wins + 1, s.Supported, s.Comparable);
        }
    }

    var winnerId = scores
        .OrderByDescending(kv => kv.Value.Wins)
        .ThenByDescending(kv => kv.Value.Comparable > 0 ? (double)kv.Value.Wins / kv.Value.Comparable : 0.0)
        .ThenByDescending(kv => kv.Value.Supported)
        .ThenBy(kv => kv.Key)
        .First().Key;
    var winnerEngine = Engines.FirstOrDefault(e => e.Id == winnerId);
    var winnerScore = scores[winnerId];
}

<div class="scoreboard" style="border-color: @(winnerEngine?.Color)28; box-shadow: 0 0 80px @(winnerEngine?.Color)08">
    <div class="scoreboard-header">
        <div class="scoreboard-header-label">Core Engine Results</div>
        <div class="scoreboard-header-title" style="background: linear-gradient(135deg, @(winnerEngine?.Color), #fff); -webkit-background-clip: text; -webkit-text-fill-color: transparent">
            &#x1F3C6; @winnerEngine?.Name Wins @winnerScore.Wins/@winnerScore.Comparable
        </div>
    </div>
    <div class="scoreboard-grid" style="grid-template-columns: repeat(@Engines.Count, 1fr)">
        @foreach (var e in Engines)
        {
            var (wins, supported, comparable) = scores[e.Id];
            var winRate = comparable > 0 ? ((double)wins / comparable) * 100.0 : 0.0;
            var isWinner = e.Id == winnerId;
            <div class="scoreboard-card @(isWinner ? "winner" : "")" style="@(isWinner ? $"background: {e.Color}0D; border-color: {e.Color}30" : "")">
                <span class="scoreboard-icon">@e.Icon</span>
                <div class="scoreboard-name" style="color: @e.Color">@e.Name</div>
                <div class="scoreboard-wins @(isWinner ? "winner-wins" : "")" style="@(isWinner ? $"color: {e.Color}" : "")">@wins</div>
                <div class="scoreboard-total">wins / @comparable comparable</div>
                <div class="scoreboard-supported">@supported supported of @Slides.Count</div>
                <div class="scoreboard-supported">win rate @winRate.ToString("F0")%</div>
                @if (isWinner)
                {
                    <div class="scoreboard-champion" style="background: linear-gradient(135deg, @e.Color, @(e.Color)CC)">&#x1F3C6; CHAMPION</div>
                }
            </div>
        }
    </div>
    <div class="scoreboard-footer">
        .NET 10 WASM &middot; Stopwatch + GC alloc tracking &middot; SQLite via Microsoft.Data.Sqlite (P/Invoke) &middot; IndexedDB via JS interop &middot; Sequential execution &middot; "Not Supported" = no native API &middot; Scores are computed on comparable slides only &middot; <strong>Note:</strong> WASM runs 2-3&times; slower than native &mdash; desktop benchmarks show higher absolute throughput for all engines.
    </div>
</div>

@code {
    [Parameter] public required Dictionary<string, IReadOnlyDictionary<string, EngineBaseResult>> Results { get; set; }
    [Parameter] public required IReadOnlyList<SlideDefinition> Slides { get; set; }
    [Parameter] public required IReadOnlyList<EngineDefinition> Engines { get; set; }
}
